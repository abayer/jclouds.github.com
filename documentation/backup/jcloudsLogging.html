<h1>Introduction</h1>

<p>JClouds log design has the following goals:</p>

<ul><li>Introduce no dependencies on third party apis such as commons-logging or log4j</li>
<li>Support pluggable log implementations or optionally none</li>
</ul><p>JClouds aims to be compatible with as many environments as possible.  Therefore, it has its own <code>org.jclouds.logging.Logger</code>.
 This interface serves two purposes:</p>

<ul><li>allow logging to be pluggable</li>
<li>allow zero-logging to be possible</li>
</ul><h2>Pluggable logging</h2>

<p>Pluggable logging is important.  While some users are ok using JDK logging, many prefer to use other
 apis such as commons logging or log4j.<br />
To widen the audience, we need a layer that protects java logging users from unnecessary<br />
dependencies while at the same time allowing log4j users the flexibility to retain a single config file.</p>

<h2>Implementation</h2>

<p>In jclouds, logging implementations are plugged-in by Guice.  Essentially classes declare a Logger member
annotated with <code>@Resource</code>, but set to a null-safe <code>Logger.NULL</code>.</p>




<p>Post-construction, a subclass of <a href="http://jclouds.googlecode.com/svn/trunk/core/src/main/java/org/jclouds/logging/config/LoggingModule.java">LoggerModule</a>
binds <a href="http://jclouds.googlecode.com/svn/trunk/core/src/main/java/org/jclouds/logging/config/BindLoggersAnnotatedWithResource.java">BindLoggersAnnotatedWithResource</a>,
 which in turn selects an appropriate Logger for the object.</p>

<p>As this injection is handled in Guice modules, developers can be largely unaware of its existence, or even Guice itself.</p>

<h2>Zero logging</h2>

<p>As high-performance API, jclouds must have means to determine the overhead incurred by I/O systems
such as logging.  As such, it is standard practice to design your components initialized with an instance of <code>NullLogger</code>.</p>

<p>At runtime, this will be overridden with an appropriate logger implementation so that benchmarks can assess performance impact.</p>

<p>Here's an example of how a developer can achieve this:</p>

<pre><code>@Resource
protected Logger logger = Logger.NULL;</code></pre>

<h2>Usage</h2>

<p>Use Guice to select the type of logging you wish to use.</p>

<p>In jclouds-core, there are two modules:</p>

<ul><li><code>NullLoggingModule</code> - does nothing</li>
<li><code>JDKLoggingModule</code> - uses java.util.logging.logger</li>
</ul><p>An additional implementation is available when you add the optional jclouds-log4j dependency:</p>

<ul><li><code>Log4JLoggingModule</code></li>
</ul><p>Here is example code of how to configure your components to use Log4J:
</p><pre><code>  public static class A {
@Resource
private Logger logger = Logger.NULL;
  }

  A a = Guice.createInjector(new Log4JLoggingModule()).getInstance(A.class);</code></pre>

<p>Note that some classes hide this away.  For example, S3ContextFactory will by default create a
<code>JDKLoggingModule</code> unless you specify otherwise.</p>

<pre><code>S3Context contextWithJDKLogging = S3ContextFactory.createS3Context("myaccesskeyid","mysecretkey");
S3Context contextWithLog4JLogging = S3ContextFactory.createS3Context("myaccesskeyid","mysecretkey", 
										new Log4JLoggingModule());</code></pre>

<h2>Logging in jclouds</h2>

<p>In effort to not conflict with other libraries, <code>jclouds</code> contains its own logging classes.
These are by default bound to <code>java.util.logging</code>, but they can be rebound to other libraries such as <code>Log4J</code> or use <code>Guice</code> configuration modules.</p>

<p>Here's an example of adding log4j logging:
</p><pre><code>// add properties that override defaults, as necessary
Properties overrides = new Properties();

//in case you are passing in configuration such as log4j
Set&lt;Module&gt; wiring = ImmutableSet.&lt;Module&gt; of(new Log4JLoggingModule());

// construct your context with the overrides in place
ComputeServiceContext context = new ComputeServiceContextFactory().createContext("terremark", user, key,
                                                              wiring, overrides);</code></pre>

<p>jclouds performs three different kinds of logging:</p>

<ul><li>Standard context logging - used within each class</li>
<li>Wire logging -- similar to what is used in the apache commons http client project</li>
<li>Abstraction logging</li>
</ul><h2>Context Logging</h2>

<p>Context Logging will show you how jclouds translates the ReST API of a service into HTTP calls,
and how HTTP results are translated back into java objects.</p>

<p>Each class has its own log named according to the class's fully qualified name.
For example the class <code>JavaUrlHttpCommandExecutorService</code> has a log named <code>org.jclouds.http.internal.JavaUrlHttpCommandExecutorService</code>.
Since all classes follow this convention it is possible to configure context logging for all classes using the single logging rule using <code>org.jclouds</code>.</p>

<h2>Wire Logging</h2>

<p>Wire Logging is intentionally near identical to the apache HTTP components project system of the same name.</p>

<p>The wire log is used to log all data transmitted to and from servers when executing HTTP requests.
This log should only be enabled to debug problems, as it will produce an extremely large amount of log data, some of it in binary format.</p>

<p>Because the content of HTTP requests is usually less important for debugging than the HTTP headers,
these two types of data have been separated into different wire logs.</p>

<p>The content log is <code>jclouds.wire</code> and the header log is <code>jclouds.headers</code>.</p>

<h2>Abstraction Logging</h2>




<p>jclouds.compute and jclouds.blobstore</p>

<p><code>Last Updated: 2011-05-26</code></p>