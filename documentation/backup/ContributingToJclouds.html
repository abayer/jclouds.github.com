<h1>Contributing to jclouds: How to develop and extend jclouds providers</h1>

<h2>Creating and working with your fork</h2>

<h3>setup your fork</h3>

<ul><li>go to github,com and fork jclouds/jclouds</li>
<li><code>git clone http://github.com/___YOUR_USER___/jclouds.git</code></li>
<li>if you are already a jclouds collaborator you can use git:// instead of http://
*<code>git remote add jclouds git://github.com/jclouds/jclouds.git</code></li>
</ul><h3>pulling changes from master</h3>

<ul><li><code>git pull jclouds master</code></li>
</ul><h2>Creating new providers with maven archetypes</h2>

<ul><li>Help developers <em>working on</em> jclouds get sub-projects up and running quickly</li>
<li>Give developers trying to <em>use</em> jclouds a hands-up in terms of project setup, dependencies and sample code</li>
</ul><p>The quickest way to make the jclouds archetypes available locally is to run
<code>mvn install</code> from the <code>jclouds/archetypes</code> directory. This will build the archetypes and place them in your local catalogue.</p>

<p>In order to create a project based <em>on</em> an archetype, navigate to the directory in which you wish the project to be created and run</p>

<p><code>mvn archetype:generate</code></p>

<h3>rest-client-archetype</h3>

<p>A template project for a jclouds client of a cloud service.</p>




<p>Parameters:</p>

<table><thead><tr><th>Name</th>
            <th>Description</th>
            <th>Default</th>
            <th>Example</th>
        </tr></thead><tr><td>*providerName*</td>
        <td>The camel case name for the service. Will be used in class names, so should not contain spaces or other invalid characters. </td>
        <td></td>
        <td>Tweeter</td>
    </tr><tr><td>*artifactId*</td> 
        <td>The name of the project. Will be prefixed with `jclouds-`, and will also be the name of the generated project directory, so should not contain invalid characters. </td>
        <td></td>
        <td>tweeter</td>
    </tr><tr><td>*providerEndpoint* </td>
        <td>The URL at which the service can be accessed. </td> 
        <td></td>
        <td>http://tweeter.com/api</td>
    </tr><tr><td>*providerIdentity*</td>
        <td>What does this provider call an identity? </td>
        <td></td>
        <td>user, account, apikey </td>
    </tr><tr><td>*providerCredential* </td>
        <td>What does this provider call a credential, associated with above?</td>
        <td></td>
        <td>password, secret, key</td>
    </tr><tr><td>*providerApiVersion*</td>
        <td>What version of the rest api are you working on? </td>
        <td></td> 
        <td>1.0, 2001-11-01</td>
    </tr><tr><td>*groupId*</td>
        <td>The Maven project groupId.</td>
        <td>org.jclouds</td>
        <td></td> 
    </tr><tr><td>*author*</td>
        <td>The author of the project.</td>
        <td>Adrian Cole</td>
        <td></td>
    </tr><tr><td>*package*</td> 
        <td>The Java base package of the project's classes.</td>
        <td> _same as_ `groupId`.`artifactId` </td>
        <td></td>
    </tr><tr><td>*version*</td>
        <td>The Maven project version.</td>
        <td>1.0-SNAPSHOT</td>
        <td></td>
    </tr></table><h3>compute-service-archetype</h3>

<p>Adds compute service components to an <em>existing</em> project.</p>

<h4>Prerequisites</h4>

<p>In order for this to work, you must use the identical parameters as json-client-archetype, and beforehand,
you must delete the files this code will replace.  Here are the files:</p>




<p>|| file || reason ||
|| src/test/resources/log4j.xml || adding compute logger||
|| src/main/java/org/jclouds/<code>artifactId</code>/<code>providerName</code>ContextBuilder || converts to build a ComputeServiceContext instead of a RestContext ||
|| src/main/java/org/jclouds/<code>artifactId</code>/<code>providerName</code>ContextFactory || converts to build a ComputeServiceContext instead of a RestContext ||</p>

<h4>Fixing up</h4>

<ul><li>You will have to change usage like context.getAPI() to context.getProviderSpecificContext().getAPI();</li>
<li>add in appropriate lines to compute.properties hooking this provider to it.</li>
<li>code in <code>providerName</code>ComputeServiceContextModule and run <code>providerName</code>ComputeServiceLiveTest until it passes.</li>
</ul><h3>Coding</h3>

<h4>Adding new operations to an existing provider</h4>

<ul><li>You will need to add http markup in <code>providerName</code>AsyncClient and its respective unit test to create a new service

<ul><li>Note that <code>providerName</code>Client must mirror method signatures in <code>providerName</code>AsyncClient except the return val is not a Future</li>
</ul></li>
<li>Here's advise for coding new methods that need http bodies parsed

<ul><li>create a method with the appropriate markup in <code>providerName</code>AsyncClient; have it return ListenableFuture<em>&lt;String</em>&gt; as a returnVal.</li>
<li>create the identical method in  <code>providerName</code>Client but have it return a String and don't add any annotations.</li>
<li>create a test method in <code>providerName</code>AsyncClientTest, and make sure this passes.</li>
<li>create a test method in <code>providerName</code>ClientLiveTest and capture the resultant string to stdout or stderr.</li>
<li>save that output to a file under test/resources related to the name</li>
<li>create a domain object under the domain package related to this output</li>
<li>create a parser that subclasses <code>ParseJson</code>, if json or `ParseSax.HandlerWithResult, if xml

<ul><li>ex ParseContainerListFromJsonResponse</li>
<li>ex AccountNameEnumerationResultsHandler</li>
</ul></li>
<li>create a test that subclasses <code>BaseHandlerTest</code>

<ul><li>ex ParseContainerListFromJsonResponseTest</li>
<li>ex AccountNameEnumerationResultsHandlerTest</li>
</ul></li>
<li>when this works

<ul><li>change the returnVal of the methods in <code>providerName</code>AsyncClient and <code>providerName</code>Client appropriately</li>
<li>add an annotation linking the parser to the result, @XMLResponseParser for xml and  @ResponseParser for anything else</li>
<li>validate/correct <code>providerName</code>AsyncClientTest</li>
</ul></li>
<li>now check your <code>providerName</code>ClientLiveTest to ensure the value indeed comes back as expected from the service.</li>
</ul></li>
</ul><h4>Multiple API versions and dialects</h4>

<p>You may be working with a service that has dialects or multiple versions present.  In general,
if there are multiple api versions present on a BETA or otherwise &lt;1.0 level service,
please keep jclouds object model in sync with the latest and make the implementation deal with prior versions.<br />
This keeps the number of parallel classes in our source down.</p>

<h4>Implementing a service dialect</h4>

<p>Services some time are based on a specific API, but follow slightly different conventions or have additional api calls.<br />
The way to handle this is to create a subinterface of the master AsyncClient and Client interfaces.<br />
Then, override the annotations on the AsyncClient where the conventions are different and also add in new methods as needed.</p>

<h3>Running Tests</h3>

<h4>Running Live Tests from the commandline</h4>

<p>There are two ways you can run tests that connect directly against the service, through eclipse or
via the commandline using maven. This is about how to run using maven.</p>

<h4>Verifying installation</h4>

<p>We currently use maven 3.0 beta 3, so ensure you have "mvn" in your path.<br />
To test this out, issue the <code>mvn -version</code> command.  It should look like below:
</p><pre><code>Adrian-Coles-MacBook-Pro:~ adrian$ mvn --version
Apache Maven 3.0-beta-3 (r990787; 2010-08-30 13:44:03+0100)
Java version: 1.6.0_20
Java home: /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home
Default locale: en_US, platform encoding: MacRoman
OS name: "mac os x" version: "10.6.4" arch: "x86_64" Family: "mac"</code></pre>

<p>Note you should be in the directory of the service you'd like to test.  For example,
if you are testing the terremark module, you should already have cloned jclouds and
changed into the vcloud/terremark directory.  Here's an example:</p>

<pre><code>Adrian-Coles-MacBook-Pro:tmp adrian$ git clone git://github.com/jclouds/jclouds.git
Initialized empty Git repository in /private/tmp/jclouds/.git/
remote: Counting objects: 58795, done.
remote: Compressing objects: 100% (14698/14698), done.
remote: Total 58795 (delta 28015), reused 58636 (delta 27916)
Receiving objects: 100% (58795/58795), 17.41 MiB | 45 KiB/s, done.
Resolving deltas: 100% (28015/28015), done.
Adrian-Coles-MacBook-Pro:tmp adrian$ cd jclouds/vcloud/terremark/</code></pre>

<h4>Invoking the tests</h4>

<p>To run against the service, you'll need to specify the maven profile live (<code>-Plive</code>).
When live is enabled, any tests that have <code>LiveTest</code> suffix will be run during the integration-test phase.<br />
In order for this to operate, you must specify the following either inside your <code>~/.m2/settings.xml</code>
or directly on the commandline:</p>

<ul><li>test.<em>provider</em>.identity</li>
<li>test.<em>provider</em>.credential (some clouds do not require this)</li>
<li>test.<em>provider</em>.endpoint (optional)</li>
<li>test.<em>provider</em>.apiversion (optional)</li>
</ul><p>Here's an example of running a live test with a specific username and password:</p>

<p><code>mvn -Plive clean install -Dtest.trmk-vcloudexpress.identity=adrian@jclouds.org -Dtest.trmk-vcloudexpress.endpoint=https://services.vcloudexpress.terremark.com/api -Dtest.trmk-vcloudexpress.credential=12312412</code></p>

<h4>When failures occur</h4>

<p>Tests can fail because of problems in code, problems in the service, or configuration issues,
such as passing the wrong credentials into the service.  The first thing to do is to review the logs of the tests that failed.</p>

<p>Here's an example of a failure:
</p><pre><code>Failed tests: 
  testConfigureNode(org.jclouds.vcloud.terremark.TerremarkVCloudClientLiveTest)
  testGet(org.jclouds.vcloud.terremark.compute.TerremarkVCloudComputeServiceLiveTest)
  cleanup(org.jclouds.vcloud.terremark.compute.TerremarkVCloudComputeServiceLiveTest)

Tests run: 41, Failures: 3, Errors: 0, Skipped: 2

[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.</code></pre>

<p>In this case, a few tests didn't pass, although most did.  There are a few logs to check into:</p>




<p>|| log || path || purpose ||
|| test log || target/surefire-reports/TestSuite.txt || shows you the line in the test code that failed and specific reason ||
|| wire log || target/test-data/jclouds-wire.log || shows you all http packets sent to the service and their responses ||
|| jclouds log || target/test-data/jclouds.log || shows you which java methods created which packets and also other debug info ||
|| ssh log || target/test-data/jclouds-ssh.log || shows you connections to other machines ||
|| abstraction log || target/test-data/jclouds-<em>compute or blobstore</em>.log || shows you high-level commands, like what node is being deployed at what time ||</p>

<h4>How to get help</h4>

<p>When failures happen, and you cannot figure out why, here's a couple places to check.<br />
Please make sure you have log files handy, and at least paste the test log for others.</p>

<ul><li>IRC - #jclouds on freenode</li>
<li><a href="http://groups.google.com/group/jclouds-dev">jclouds-dev google group</a></li>
</ul><h2>Creating a new release</h2>




<p>TODO but check <a href="http://code.google.com/p/jclouds/issues/detail?id=265">here</a> for now.</p>

<h2>Advanced</h2>

<h3>Exception conversion</h3>

<p>Jclouds converts exceptions from http into domain specific exceptions,
and can also convert domain-specific exceptions into valid values.</p>

<h4>Per context coercion of http data into an Exception</h4>

<p>The <code>HttpErrorHandler</code> applies to all commands within a rest context.</p>

<p>For example, you can use <code>bindErrorHandlers()</code> in your subclass
of <code>RestClientModule</code> to specify a <code>HttpErrorHandler</code> which takes
an  <code>HttpCommand</code>and  <code>HttpResponse</code> and convert it them into a relevant exception.<br />
Here's an example of taking a 404 and turning it into a <code>ResourceNotFoundException</code></p>

<pre><code>case 404:
  if (!command.getRequest().getMethod().equals("DELETE")) {
     exception = new ResourceNotFoundException(message, exception);
  }
  break;</code></pre>

<h4>Special RuntimeException Types</h4>

<p>Certain exceptions are propagated, even if nested inside other exceptions.<br />
These allow jclouds code to operate without exception searching.</p>

<p>For example, you could wrap any jclouds command in the following reliably:</p>

<pre><code>try {
    String = client.getFoo("bar");
} catch (AuthorizationException e) {
    // even if the auth exception was under the scenes wrapped in an http exception, 
    // the first exception of type AuthorizationException will show up here.  This allows
    // you to make preventative measures that ensure your code doesn't lock out accounts.
}</code></pre>

<p>Here's a list of our "standard" exceptions which are defined in
 <code>org.jclouds.util.Utils#returnFirstExceptionIfInListOrThrowStandardExceptionOrCause</code>:</p>

<ul><li>IllegalStateException</li>
<li>UnsupportedOperationException</li>
<li>IllegalArgumentException</li>
<li>AuthorizationException</li>
<li>ResourceNotFoundException</li>
<li>HttpResponseException</li>
</ul><h4>Per method conversion of an Exception into another exception or a value</h4>

<p>You may have a method that is valid if an exception occurs.</p>

<p>For example, an <code>exists(resource)</code> method would return ListenableFuture, if in the AsyncClient,
and boolean if in the normal Client.  In this case, a <code>ResourceNotFoundException</code>
simply means the resource isn't there, and should return false, rather than throw an exception.<br />
On you AsyncClient, decaare an <code>ExceptionParser</code> on the method you'd like to control.</p>

<p>Here's an example of common conventions, where an exception is ok:
</p><pre><code>@DELETE
@ExceptionParser(ReturnVoidOnNotFoundOr404.class)
@Path("")
ListenableFuture&lt;Void&gt; deleteResource(@EndpointParam URI resourceHref);

@GET
@Endpoint(Images.class)
@Path("")
@ExceptionParser(ReturnEmptySetOnNotFoundOr404.class)
@XMLResponseParser(ImagesHandler.class)
ListenableFuture&lt;? extends Set&lt;Image&gt;&gt; listImages();

@GET
@ExceptionParser(ReturnNullOnNotFoundOr404.class)
@Path("")
@XMLResponseParser(InstanceHandler.class)
ListenableFuture&lt;Instance&gt; getInstance(@EndpointParam URI instanceHref);
</code></pre>

<h4>Creating new http methods</h4>

<p>Sometimes, standard http methods will not do.  For example, you may need to use http PROPFIND.
 To do this, you first need to create an annotation for the new method, then use that in your markup.  See below:</p>

<pre><code>
@Target( { ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@HttpMethod("ROWDY")
public @interface ROWDY {
}

@ROWDY
@Path("objects/{id}")
ListenableFuture&lt;Boolean&gt; rowdy(@PathParam("id") String path);</code></pre>

<h3>Dealing with Enums</h3>

<p>Many clouds are attempting to create ec2, s3, or vcloud compatible apis.<br />
Often it is the case that they get data values wrong.  When this happens, IllegalArgumentExceptions are thrown.<br />
As a general practice, we shouldn't throw an exception on something that is parsed from a server, as it probably
isn't critical (ex. new instance type, state, etc.)  In fact, throwing an exception essentially disables functionality.<br />
Instead, let's return UNRECOGNIZED for any enums we cannot parse.</p>

<p><code>Last Updated: Thu Jun  2 14:05:57 2011</code></p>