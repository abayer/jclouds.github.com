<h1>User Guide: How to use the Compute API and tools</h1>

<h2>Introduction =</h2>

<p>The jclouds Compute API provides a basic abstraction across Compute APIs such as Amazon EC2 and VMware vCloud.<br />
We also have integrations for popular tools such as Ant and Maven.</p>

<h2>Features</h2>

<h3>Location Aware API</h3>

<p>Unlike other tools, our compute api doesn't require you to establish multiple connections to clouds who are multi-homed.
For example, you can use the same object to access your resources in all regions of EC2.<br />
This allows you greater visibility into your resources and provides means to logically tie cross-wan resources together.</p>

<h3>Node Sets</h3>

<p>Using our compute API, you can run multiple nodes as a set regardless of the underlying cloud API.<br />
In this way, you can fire up a 20 node cluster and manage it by its group name, as opposed to dealing with each node individually.</p>

<h3>SSH keys</h3>

<p>Our compute API natively helps with moving your ssh keys to the node on startup, so that
you don't have to worry about remembering or storing random passwords or keys provided by the service.</p>

<h3>Run Script</h3>

<p>Our runScript features provide simple means for executing scripts on the machines in a set.<br />
It also includes special exception types that will allow you to handle errors appropriately.</p>

<h3>Stub Provider</h3>

<p>As more people are looking at concepts like devops, it follows that infrastructure as code implies testability as a concern.
One of our steps to help is the addition of a stub compute provider, which you can join with our in-memory blobstore to
test your provisioning instructions before you try them out with your credit card:</p>

<h3>Credential persistence</h3>

<p>As of jclouds beta-9, you can now supply a map to persist credentials of your nodes across connections.  Using a blobstore-backed map,
this means you can keep track of all of your cloud nodes' credentials in a single place.</p>

<h3>Supported Providers</h3>

<p>All of the following providers can be used equally in any Compute API tool.</p>




<p>|| <em>maven dependency</em> || <em>iso 3166 codes</em> ||
||org.jclouds.provider/aws-ec2||US-VA,US-CA,IE,SG||
||org.jclouds.provider/bluelock-vcloud-vcenterprise||US-IN||                                                                                                                            <br />
||org.jclouds.provider/bluelock-vcloud-zone01||US-IN||
||org.jclouds.provider/cloudservers-uk||GB-SLG||
||org.jclouds.provider/cloudservers-us||US-IL,US-TX||
||org.jclouds.provider/cloudsigma-zrh||CH-ZH||
||org.jclouds.provider/elastichosts-lon-b||GB-LND||
||org.jclouds.provider/elastichosts-lon-p||GB-LND||
||org.jclouds.provider/elastichosts-sat-p||US-TX||
||org.jclouds.provider/eucalyptus-partnercloud-ec2||US-CA||
||org.jclouds.provider/gogrid||US-CA,US-VA||
||org.jclouds.provider/openhosting-east1||US-VA||
||org.jclouds.provider/rimuhosting||compute||NZ-AUK,US-TX,AU-NSW,GB-LND||
||org.jclouds.provider/serverlove-z1-man||GB-MAN||
||org.jclouds.provider/skalicloud-sdg-my||MY-10||
||org.jclouds.provider/slicehost||US-IL,US-TX,US-MO||
||org.jclouds.provider/stratogen-vcloud-mycloud||compute||GB||
||org.jclouds.provider/trmk-ecloud||US-FL,NL-NH||
||org.jclouds./trmk-vcloudexpress||US-FL||</p>

<p>You can also set the context property <code>provider</code>.endpoint to use the following APIs for your private cloud</p>

<p>|| <em>maven dependency</em> ||                                                                                                                                                                <br />
||org.jclouds.api/byon||                                                                                                                                                                <br />
||org.jclouds.api/deltacloud||                                                                                                                                                          <br />
||org.jclouds.api/elasticstack||                                                                                                                                                        <br />
||org.jclouds.api/eucalyptus||                                                                                                                                                          <br />
||org.jclouds.api/nova||                                                                                                                                                                <br />
||org.jclouds.api/vcloud||</p>

<p><em>Note, that if you use the <code>jclouds-allcompute</code> dependency, your project will have all of the above!</em></p>

<h2>API</h2>

<p>== Concepts ==
The Compute API is a portable means of managing nodes in clouds. It can manage nodes as a
set and address resources in any cloud without needing separate connections. It also has a
Template feature which allows you to search for configurations that match parameters such as
CPU count or operating sytem.  Finally, it contains utilities to execute scripts as part of
the bootstrap process of your nodes.</p>

<h3>Template</h3>

<p>Templates are a way of encapsulating the requirements of your nodes such that similar configurations can be launched in other clouds.</p>

<p>A Template consists of the following elements:</p>

<ul><li>Image - defines which bytes boot your node, and details such as the operating system you wish to run.</li>
<li>Hardware - defines CPU, memory, disk, and supported architecture .</li>
<li>Location - defines the region or datacenter in which your node(s) should run.</li>
<li>Options - defines optional parameters such as inbound ports to open or scripts to execute at boot time.</li>
</ul><p>Templates can be created from your service context via a TemplateBuilder.  This builder allows you
to specify your requirements with statements such as <code>minCores</code> and <code>imageId</code>.</p>

<h3>Operating System</h3>

<p>An Image is different from an Operating System. It is really a bunch of state that includes an operating system,
software and configuration. It is often versioned independently of the operating system.
Before, we lumped together operating system with image, as this is what amazon and some others did.
However, this assumes nodes are created from images. This is not the case in OVF-based systems like vCloud,
and we really had no clean way to address this before. Operating System as a type works much cleaner and across more systems.</p>

<h3>Hardware</h3>

<p>We previously had a class called Size which held a combination of size and hardware configuration data.
While simple, it limited our ability to address fine grained concerns, as it assumed there is
only a single disk, processor, etc. Our new Hardware type is much more robust, while still extremely simple to use.
While mounted volume information is read-only at the moment, expect us to add portability over systems like EBS and vCloud volumes in the near future.</p>

<h3>Usage</h3>

<p>Using the API is straightforward. You need to create a context to the service you wish to manage, and then act on it.
Here's how to perform common commands.</p>

<h3>Open your context and get a service reference</h3>

<p>Here, you specify the particular service you wish to manage and get a reference to <code>ComputeService</code></p>

<pre><code>ComputeServiceContext context = new ComputeServiceContextFactory()
             .createContext("terremark", user, password);

ComputeService computeService = context.getComputeService();</code></pre>

<h3>List the nodes you have in all locations</h3>

<p>As mentioned above, this context can operate all of your nodes across the globe.  Here's how to list them:</p>

<pre><code>for (ComputeMetadata node : client.listNodes()) {
   node.getId(); // how does jclouds address this in a global scope
   node.getProviderId(); // how does the provider api address this in a specific scope
   node.getName(); // if the node is named, what is it?
   node.getLocation(); // where in the world is the node
}</code></pre>

<p>Note that the result is of type <code>ComputeMetadata</code> rather than the more useful <code>NodeMetadata</code>.<br />
This is because many services offer only minimal details on listing.  To flesh out the objects you want,
call the <em>Get Node Metadata</em> command.</p>

<h3>Get Node Metadata</h3>

<p>Use the <em>Get Node Metadata</em> command to retrieve commonly required information about a node.
</p><pre><code>NodeMetadata metadata = client.getNodeMetadata(node);
metadata.getId();
metadata.getProviderId(); 
metadata.getLocation();
metadata.getName();
metadata.getGroup();// if part of a nodeset, this identifies which one.
metadata.getHardware();
metadata.getImageId(); // if the node was created by an image, what is its id?
metadata.getOperatingSystem();
metadata.getState();
metadata.getPrivateAddresses();
metadata.getPublicAddresses();
metadata.getCredentials();// only available after createNodesInGroup, identifies login user/credential</code></pre>

<h3>List Assignable Locations</h3>

<p>The <em>List Assignable Location</em> command returns all the valid locations for nodes.<br />
The list locations command returns all the valid locations for nodes.
A location has a scope, which is typically region or zone. A region is a general area,
like eu-west, where a zone is similar to a datacenter. If a location has a parent,
that implies it is within that location. For example a location can be a rack, whose parent is likely to be a zone.</p>

<pre><code>Set&lt;? extends Location&gt; listAssignableLocations();</code></pre>

<h3>List Hardware Profiles</h3>

<p>The <em>List Hardware Profiles</em> command returns settings including virtual CPU count, memory, and disks.</p>

<p>CPU count is not a portable quantity across clouds, as they are The list hardware profiles
command shows you the options including virtual cpu count, memory, and disks. cpu count is not
a portable quantity across clouds, as they are measured differently. However, it is a good indicator of
 relative speed within a cloud. memory is measured in megabytes and disks in gigabytes.</p>

<pre><code>Set&lt;? extends Hardware&gt; listHardwareProfiles();</code></pre>

<h3>List Images</h3>

<p>The <em>List Images</em> command define the operating system and metadata related to a node.<br />
In some clouds, images are bound to a specific region, and their identifiers are different across regions.<br />
For this reason, you should consider matching image requirements like operating system family with TemplateBuilder as opposed to choosing an image explicitly.</p>

<pre><code> Set&lt;? extends Image&gt; listImages();</code></pre>

<h3>Create Nodes with Group</h3>

<p>The compute API treats nodes as a group based on a group you specify. Using this group,
you can choose to operate on one or many nodes as a logical unit without regard to the implementation details of the cloud.</p>

<p><code>createNodesInGroup</code> returns all of the nodes the API was able to launch into in a running state with port 22 open.
If resources such as security groups are needed, they will be reused or created for you.
Here's an example of how to start a nodeSet:</p>

<pre><code>NodeSet nodes = client.createNodesInGroup(group, 2, template);</code></pre>

<p>The set that is returned will include credentials you can use to ssh into the nodes.
The "credential" part of the credentials is either a password or a private key. You have to inspect the value to determine this.<br />
Make sure you look also at the "identity" part of the credentials object so that you don't attempt to login as the wrong user.</p>

<pre><code>if (node.getCredentials().credential.startsWith("-----BEGIN RSA PRIVATE KEY-----"))
 // it is a private key, not a password.</code></pre>

<p>Note: If all you want to do is execute a script at bootup, you should consider use of the runScript option.</p>

<h3>Predicate Commands</h3>

<p>Commands ending in <code>Matching</code> allow you to decide which subset of nodes you with to affect.<br />
All predicate commands are run in parallel for highest efficiency.</p>

<h4>Example Predicates</h4>

<p>There are a number of predicates in the <code>NodePredicates</code> class.  Here are a few combinations that you may find interesting:</p>

<ul><li><code>runningInGroup(group)</code> - affect any nodes that are already running, refined to a specific group</li>
</ul><pre><code>import static org.jclouds.compute.predicates.NodePredicates.runningInGroup;
import static org.jclouds.compute.options.RunScriptOptions.Builder.overrideCredentialsWith;

Map&lt;? extends NodeMetadata, ExecResponse&gt;  responses = client.runScriptOnNodesMatching(runningInGroup(group), script,
                  overrideCredentialsWith(creds));</code></pre>

<ul><li><code>and(withGroup(group), not(TERMINATED))</code> match everything that has a group, but not destroyed.</li>
</ul><pre><code>import static com.google.common.base.Predicates.*;
import static org.jclouds.compute.predicates.NodePredicates.*;
import static com.google.common.collect.Iterables.*;

Iterable&lt;? extends NodeMetadata&gt; billedNodes = filter(client.listNodesDetailsMatching(all()), and(withGroup(group), not(TERMINATED))));
</code></pre>

<h4>Commands</h4>

<h5>Destroy Nodes Matching Predicate</h5>

<p>nodes matching the filter are destroyed as a logical set. <br />
When the last node in a set is destroyed, any indirect resources it uses, such as keypairs, are also destroyed.  Ex. here's how to destroy all nodes with a specific group:</p>

<pre><code>import static org.jclouds.compute.predicates.NodePredicates.*;
   client.destroyNodesMatching(withGroup(group));</code></pre>

<h5>Reboot Nodes Matching Predicate</h5>

<p>Ex. here's how to reboot all nodes with a specific group:</p>

<pre><code>import static org.jclouds.compute.predicates.NodePredicates.*;
   client.rebootNodesMatching(withGroup(group));</code></pre>

<h5>Run Script on Nodes Matching Predicate</h5>

<p>Here's how to run a script on all nodes as root with the credentials that they were created with.</p>

<pre><code>import static org.jclouds.compute.predicates.NodePredicates.runningInGroup;

responses = client.runScriptOnNodesMatching(runningInGroup(group), script);</code></pre>

<p>If you created your nodes using the <code>authorizePublicKey</code> option, then you are probably interested in using that again here.<br />
However, you should always look up the login user associated with the host, as it may not be root.</p>

<p><em>Note</em> if you think this should change, please file an issue.  For example, we could in the future create a
sudo-able login user on the nodes, simplifying this process.</p>

<pre><code>import static org.jclouds.compute.predicates.NodePredicates.runningInGroup;
import static org.jclouds.compute.options.RunScriptOptions.Builder.overrideCredentialsWith;
import static org.jclouds.compute.options.TemplateOptions.Builder.authorizePublicKey;

nodes = client.createNodesInGroup(group, 1, authorizePublicKey(myKey));
Credentials good = nodes.iterator().next().getCredentials();

// save this off
loginUser = good.identity;

// later, you will use your key with the default login user
responses = client.runScriptOnNodesMatching(runningInGroup(group), script,
                  overrideCredentialsWith(new Credentials(loginUser, myKey));</code></pre>

<h5>Working with credentials</h5>

<p>Note that by default, jclouds stores credentials in a static member.<br />
If you close and reopen your compute context, your credentials will still be accessible.<br />
If you'd like to have credentials persist across compute service contexts, then supply a backing map like below:</p>

<pre><code>// set the location of the filesystem you wish to persist credentials to
props.setProperty(FilesystemConstants.PROPERTY_BASEDIR, "/var/gogrid");

blobContext = new BlobStoreContextFactory().createContext("filesystem", "foo", "bar", ImmutableSet.&lt;Module&gt;of(), props);

credentialsMap = blobContext.createInputStreamMap("credentials");

computeContext = new ComputeServiceContextFactory().createContext("gogrid", secret, apiKey,
         ImmutableSet.of(new CredentialStoreModule(credentialsMap)));</code></pre>

<h3>Individual Node Commands</h3>

<p>Individual commands are executed against a specific node's <code>id</code> (not <code>providerId</code>!).<br />
You can save time if you know you are only affecting one node, and don't need jclouds' help finding it.</p>

<h4>Commands</h4>

<h5>Get Node Metadata</h5>

<p>If you save a node's id to disk, you can inflate it later without querying by using the <code>getNodeMetadata</code> command.</p>

<pre><code>NodeMetadata metadata = client.getNodeMetadata(savedId);</code></pre>

<h5>Destroy Node</h5>

<h5>Reboot Node</h5>

<h3>Logging</h3>

<p>You can now see status of compute commands by enabling at least DEBUG on the log category: "jclouds.compute".  Here is example output:</p>

<pre><code>2010-02-06 09:43:54,985 DEBUG [jclouds.compute] (main) &gt;&gt; providing images
2010-02-06 09:44:01,186 DEBUG [jclouds.compute] (main) &lt;&lt; didn't match os(folding)
2010-02-06 09:44:01,642 DEBUG [jclouds.compute] (main) &lt;&lt; images(614)
2010-02-06 09:44:01,672 DEBUG [jclouds.compute] (main) &gt;&gt; terminating servers by group(ec2)
2010-02-06 09:44:03,314 DEBUG [jclouds.compute] (main) &lt;&lt; destroyed
2010-02-06 09:44:03,900 DEBUG [jclouds.compute] (main) &gt;&gt; searching params([arch=null, biggest=false, fastest=false, imageDescription=null, imageId=null, imageVersion=null, location=us-east-1, minCores=0, minRam=0, os=ubuntu, osDescription=null, sizeId=null])
2010-02-06 09:44:03,906 DEBUG [jclouds.compute] (main) &lt;&lt;   matched image([id=ami-87a243ee, name=9.10, locationId=us-east-1, architecture=X86_64, osDescription=alestic-64/ubuntu-9.10-karmic-base-64-20090623.manifest.xml, osFamily=ubuntu, version=20090623])
2010-02-06 09:44:03,907 DEBUG [jclouds.compute] (main) &lt;&lt;   matched size([id=m1.large, cores=4, ram=7680, disk=850, supportedArchitectures=[X86_64]])
2010-02-06 09:44:03,907 DEBUG [jclouds.compute] (main) &lt;&lt;   matched location([id=us-east-1, scope=REGION, description=us-east-1, parent=null, assignable=true])
2010-02-06 09:44:03,909 DEBUG [jclouds.compute] (main) &gt;&gt; creating keyPair region(us-east-1) name(ec2)
2010-02-06 09:44:06,886 DEBUG [jclouds.compute] (main) &lt;&lt; created keyPair(ec2)
2010-02-06 09:44:06,886 DEBUG [jclouds.compute] (main) &gt;&gt; creating securityGroup region(us-east-1) name(ec2)
2010-02-06 09:44:07,243 DEBUG [jclouds.compute] (main) &lt;&lt; created securityGroup(ec2)
2010-02-06 09:44:07,243 DEBUG [jclouds.compute] (main) &gt;&gt; authorizing securityGroup region(us-east-1) name(ec2) port(22)
2010-02-06 09:44:07,824 DEBUG [jclouds.compute] (main) &lt;&lt; authorized securityGroup(ec2)
2010-02-06 09:44:07,828 DEBUG [jclouds.compute] (main) &gt;&gt; running 2 instance region(us-east-1) zone(null) ami(ami-87a243ee) type(m1.large) keyPair(ec2) securityGroup(ec2)
2010-02-06 09:44:09,239 DEBUG [jclouds.compute] (main) &lt;&lt; started instances(i-7c180614,i-7e180616)</code></pre>

<p>If you are using the Log4JLoggingModule, here is an example log4j.xml stanza you can use to enable compute logging:
</p><pre><code>&lt;appender name="COMPUTEFILE" class="org.apache.log4j.DailyRollingFileAppender"&gt;
     &lt;param name="File" value="logs/jclouds-compute.log" /&gt;
     &lt;param name="Append" value="true" /&gt;
     &lt;param name="DatePattern" value="'.'yyyy-MM-dd" /&gt;
     &lt;param name="Threshold" value="TRACE" /&gt;
     &lt;layout class="org.apache.log4j.PatternLayout"&gt;
         &lt;param name="ConversionPattern" value="%d %-5p [%c] (%t) %m%n" /&gt;
     &lt;/layout&gt;
&lt;/appender&gt;

&lt;appender name="ASYNCCOMPUTE" class="org.apache.log4j.AsyncAppender"&gt;
     &lt;appender-ref ref="COMPUTEFILE" /&gt;
&lt;/appender&gt;

&lt;category name="jclouds.compute"&gt;
     &lt;priority value="TRACE" /&gt;
     &lt;appender-ref ref="ASYNCCOMPUTE" /&gt;
&lt;/category&gt;</code></pre>

<h2>Usage in Google AppEngine</h2>

<p>Please see [][UsingJCloudsWithGAE]]</p>

<h2>Advanced Usage</h2>

<p>Almost all advanced features require ssh.  You will likely also want to use log4j and our
enterprise configuration module.  Here's how to configure these.</p>

<pre><code>Properties overrides = new Properties();
Set&lt;Module&gt; wiring = ImmutableSet.of(new JschSshClientModule(), new Log4JLoggingModule(), new EnterpriseConfigurationModule());
ComputeServiceContext context = new ComputeServiceContextFactory().createContext("terremark", user, password,
             wiring, overrides);</code></pre>

<p>For mode information, check out the <a class="internal present" href="/jcloudsAPI.html">jcloudsAPI</a> wiki page.</p>

<h3>Uploading binary files to the node</h3>

<p>You'll need to get an ssh client for the node in order to upload files in the current version of jclouds.</p>

<p>if you just created the node, it will have login credentials set in node.getCredentials().  Ask for an ssh client based on the node.</p>

<pre><code>client = context.utils().sshForNode().apply(node);</code></pre>

<p>if the node's credentials aren't set, you'll have to assign them first.</p>

<pre><code>client = context.utils().sshForNode().apply(NodeMetadataBuilder.fromNodeMetadata(node).credentials(
	                   new Credentials("adrian",sshKeyInString)).build());</code></pre>

<p>Once you have the client, you can push files to it</p>

<pre><code>client.put("/path/to/file", Payloads.newFilePayload(contents));</code></pre>

<h3>Selecting a correct package manager</h3>

<p>Below, you'll see how you can consolidate bootstrap instructions when empowered with an operating system type.
 No more listing the dozen flavors of compatible unix's when all you're really concerned about is the package manager:</p>

<pre><code>if (OperatingSystemPredicates.supportsApt().apply(os))
  return RunScriptData.APT_RUN_SCRIPT;
else if (OperatingSystemPredicates.supportsYum().apply(os))
  return RunScriptData.YUM_RUN_SCRIPT
else if (OperatingSystemPredicates.supportsZypper().apply(os))
  return RunScriptData.ZYPPER_RUN_SCRIPT;
else
  throw new IllegalArgumentException("don't know how to handle" + os.toString());</code></pre>

<h3>Opening ports</h3>

<p>Unless you specify otherwise, only access to public IP on port 22 is explicitly configured.<br />
In clouds such as hosting.com and Rackspace, this doesn't matter, as all services are available by default.<br />
However, in clouds like Terremark and EC2, you will want to open at least 1 additional port most of the time.<br />
Here's how:</p>

<pre><code>import static org.jclouds.compute.options.TemplateOptions.Builder.inboundPorts;
...
      Template template = client.templateBuilder().options(inboundPorts(22, 8080)).build();
      // start 2 nodes
      nodes = client.createNodesInGroup(group, 2, template);
</code></pre>

<h3>Template Matching</h3>

<h4>Matching an operating system version</h4>

<pre><code>template = client.templateBuilder().hardwareId(InstanceType.M1_SMALL)
                  .osVersionMatches("10.04").imageDescriptionMatches("ubuntu-images").osFamily(OsFamily.UBUNTU).build();</code></pre>

<h3>Authorizing your RSA SSH Public Key</h3>

<p>The compute API supports authorizing a public key on a node or node set.<br />
This allows you to use a single credential across the entire set of nodes.<br />
Note that this does not change the private key of the node.<br />
If you are interested in changing the private key, look at the <code>installPrivateKey</code> option.</p>

<p>In order to use this feature, you must generate or load your RSA public key into a String.  Set the option <code>authorizePublicKey</code> to this value.  Note that if you have done this correctly, your key will start with <code>ssh-rsa</code>.</p>

<p>Ex.
</p><pre><code>import static org.jclouds.compute.options.TemplateOptions.Builder.authorizePublicKey;
...
      Template template = client.templateBuilder().options(authorizePublicKey(Payloads.newPayload(new File("/home/me/.ssh/id_rsa.pub")).build();
      // start 10 nodes
      nodes = client.createNodesInGroup(group, 10, template);</code></pre>

<p>Note that SSH must be configured for this feature to work.</p>

<h3>Installing your RSA SSH Private Key</h3>

<p>The compute API supports replacing the node's private key with one you specify.<br />
This is different than authorizing your public key.  The private key determines the identity of
root on your machine so that outgoing SSH can be authorized. You can use this feature alongside
authorizing RSA to establish an SSH mesh.  An SSH mesh can be used to manage tools such as Hadoop.</p>

<p>In order to use this feature, you must generate or load your RSA key into a String.  Set the option
<code>installPrivateKey</code> to this value.  Note that if you have done this correctly, your key will start with
<code>-----BEGIN RSA PRIVATE KEY-----</code>.</p>

<p>Ex.
</p><pre><code>import static org.jclouds.compute.options.TemplateOptions.Builder.installPrivateKey;
...
      // start 10 nodes
      nodes = client.createNodesInGroup(group, 10, installPrivateKey(Files.toString(new File("/home/me/.ssh/id_rsa"));</code></pre>

<p>Note that SSH must be configured for this feature to work.</p>

<h3>Adding a post-boot script</h3>

<p>The compute API supports injection and execution of a single file as <code>root</code> post-bootup.<br />
The exact implementation depends on the features offered by the target cloud.</p>

<p>In order to use this feature, you must generate or load a script as a jclouds <code>Statement</code> or a String value.<br />
Set the option <code>runScript</code> to this value.</p>

<p>Ex.
</p><pre><code>import static org.jclouds.compute.options.TemplateOptions.Builder.runScript;
...
      // start 10 nodes
      nodes = client.createNodesInGroup(group, 10, runScript(Files.toString(new File("runscript.sh")));</code></pre>

<p>Note that SSH must be configured for this feature to work.</p>

<h4>Default Template</h4>

<p>While many configurations may work with runScript, we setup the default template so that it can work
without parameters (ex. <code>templateBulder().build()</code> works).</p>

<h5>1.0-beta-7</h5>

<p>As of jclouds 1.0-beta-7, here are the template patterns that represent the default template.</p>

<p><em>Unless specified below, the default template is <code>osFamily(UBUNTU)</code></em></p>




<p>|| <em>provider</em> || <em>default template</em> ||
|| cloudservers || osFamily(UBUNTU).imageNameMatches(".<em>10\.?04.</em>") ||
|| ec2 || osFamily(AMZN_LINUX).os64Bit(true) ||
|| eucalyptus || osFamily(CENTOS) ||
|| gogrid || osFamily(CENTOS).imageNameMatches(".<em>w/ None.</em>") ||
|| rimuhosting || hardwareId("MIRO1B").osFamily(UBUNTU).os64Bit(false).imageNameMatches(".<em>10\.?04.</em>") ||
|| slicehost || osFamily(UBUNTU).imageNameMatches(".<em>10\.?04.</em>") ||</p>

<h5>1.0.0</h5>

<p>As of jclouds 1.0.0 here are the template patterns that represent the default template.</p>

<p><em>Unless specified below, the default template is <code>osFamily(UBUNTU).osVersionMatches("10.04").os64Bit(true)</code></em></p>

<p>TODO: This is significantly out of date.</p>




<p>|| <em>provider</em> || <em>default template</em> ||
|| vcloud/bluelock-vcdirector || osFamily(UBUNTU).os64Bit(true) ||
|| trmk-vcloudexpress || osFamily(UBUNTU).osDescriptionMatches(".<em>JeOS.</em>").os64Bit(true) ||
|| trmk-ecloud || osFamily(CENTOS).os64Bit(true) ||
|| ec2 || osFamily(AMZN_LINUX).os64Bit(true) ||
|| eucalyptus || osFamily(CENTOS) ||
|| gogrid || osFamily(CENTOS).imageNameMatches(".<em>w/ None.</em>") ||</p>

<h5>Test Scripts =====</h5>

<ul><li>OperatingSystemPredicates.supportsApt().apply(node.getOperatingSystem())</li>
</ul><pre><code>echo nameserver 208.67.222.222 &gt;&gt; /etc/resolv.conf
cp /etc/apt/sources.list /etc/apt/sources.list.old
sed 's~us.archive.ubuntu.com~mirror.anl.gov/pub~g' /etc/apt/sources.list.old &gt;/etc/apt/sources.list
apt-get update
apt-get install -f -y --force-yes openjdk-6-jdk</code></pre>

<ul><li>OperatingSystemPredicates.supportsYum().apply(node.getOperatingSystem())</li>
</ul><pre><code>echo nameserver 208.67.222.222 &gt;&gt; /etc/resolv.conf
echo "[jdkrepo]" &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo
echo "name=jdkrepository" &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo
echo "baseurl=http://ec2-us-east-mirror.rightscale.com/epel/5/i386/" &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo
echo "enabled=1" &gt;&gt; /etc/yum.repos.d/CentOS-Base.repo
yum --nogpgcheck -y install java-1.6.0-openjdk
echo "export PATH=ed5660cafcc6afd28e0f435b76b45f98b43465e4quot;/usr/lib/jvm/jre-1.6.0-openjdk/bin/:\$PATHed5660cafcc6afd28e0f435b76b45f98b43465e4quot;" &gt;&gt; /root/.bashrc</code></pre>

<h2>Clojure</h2>

<h2>Setup</h2>

<ul><li>install [http://github.com/technomancy/leiningen lein]</li>
<li><code>lein new mygroup/myproject</code></li>
<li><code>cd myproject</code></li>
<li><code>vi project.clj</code></li>
</ul><pre><code>(defproject mygroup/myproject "1.0.0" 
  :description "FIXME: write"
  :dependencies [[org.clojure/clojure "1.2.0"]
                 [org.clojure/clojure-contrib "1.2.0"]
                 [org.jclouds/jclouds-allcompute "1.0.0"]]
  :repositories [["jclouds" "https://oss.sonatype.org/content/repositories/releases"]])</code></pre>

<pre><code>* for snapshot
</code></pre>

<pre><code>(defproject mygroup/myproject "1.0.0" 
  :description "FIXME: write"
  :dependencies [[org.clojure/clojure "1.2.0"]
                 [org.clojure/clojure-contrib "1.2.0"]
                 [org.jclouds/jclouds-allcompute "1.0-SNAPSHOT"]]
  :repositories {
               "jclouds-snapshot" "https://oss.sonatype.org/content/repositories/snapshots"})</code></pre>
  * <code>lein deps</code>

<h3>Usage</h3>

<p>Execute <code>lein repl</code> to get a repl, then paste the following or write your own code.  Clearly,
you need to substitute your accounts and keys below.</p>

<pre><code>(use 'org.jclouds.compute)

(with-compute-service ["cloudservers" "email" "password"]
  (nodes))</code></pre>

<p>Here's an example of creating and running a small linux node with the group webserver:</p>

<pre><code>; create a compute service using ssh and log4j extensions
(def compute 
  (compute-service provider user password :ssh :log4j))

(create-node "webserver" compute)</code></pre>

<h2>Tools</h2>

<p>We've looked at many tools and chosen a few to spend time integrating with.<br />
These tools enable developers to focus on working code, as opposed to &#x2028;build and infrastructure engineering</p>

<h3>Ant</h3>

<p>Please check <a class="internal present" href="/ApacheAntComputeGuide.html">ApacheAntComputeGuide</a> on how to use ant for compute API tasks.</p>

<p><code>Last Updated: 2011-07-26</code></p>