<h1>Design and Usage of the InitBuilder components</h1>

<h2>Introduction =</h2>

<p>InitBuilder gives  you a standard, predictable and portable way of controlling
the lifecycle of your applications at a process level.  For example, using InitBuilder,<br />
you to setup something like Tomcat on your Windows laptop and move it to a remote Linux machine.</p>

<pre><code>TODO example</code></pre>

<p>InitBuilder introduces standard system variables, directory structures and
 writes portable initialization scripts.  The initialization scripts help level
the operating environment across operating system platforms.<br />
Standard directory paths help you avoid multi-tenancy conflicts and the need to access the root user.</p>

<h2>Vocabulary</h2>

<ul><li>Platform - a cross-platform product, like JBoss, Tomcat, Apache httpd, which as base binaries and configuration applicable to all instantiations of it.  Platforms that do not work on most operating systems are out of scope.  These include products that only exist on Windows such as [http://en.wikipedia.org/wiki/Internet_Information_Services IIS]</li>
<li>Instance - an instance of a platform, most often implemented as a process on the host operating system.  Multiple instances must be able to run on the same host without conflicts.</li>
<li>Environment Variable -  Environment variables are a set of dynamic named values that can affect the way running processes will behave on a computer. [http://en.wikipedia.org/wiki/Environment_variable ref]</li>
<li>Environment Module - Introduces environment variables for a particular scope.  These are overridable.</li>
</ul><h2>Design</h2>

<h3>Environment Management</h3>

<p>Environment Variables are typically set in a user profile.<br />
However, this user profile is generally not built from a source controlled system, and
 is unpredictable at best. Process portability requires that we ensure that important variables such as
 ones that maintain time zone information (<code>TZ</code> on Unix) and system library search path<br />
(<code>LD_LIBRARY_PATH</code> on Unix or <code>PATH</code> on windows) do not bleed in from the user or the operating system.<br />
When these are not controlled, application portability cannot be guaranteed.<br />
This problem is well known, and projects such as <a href="http://modules.sourceforge.net/">Modules</a> seek to address it.</p>

<p>Like other parts of InitBuilder, this process has to be portable.   The "important" environment variables
 are not the same across Windows and UNIX-like operating systems like Linux.<br />
InitBuilder process involves the same process, and implements it differently based on the os.<br />
Basically, the script generated by InitBuilder has a <code>sync</code> command.<br />
This <code>sync</code> command reads environment modules and creates a script or service used to run the Instance in the background.</p>

<h3>Clearing the Environment</h3>

<p>There are a couple environment variables that are named differently on operating system families.<br />
We have normalized names of these so that they can be set in a cross-platform way.</p>

<ul><li>LIBRARY_PATH - In unix this is <code>LD_LIBRARY_PATH</code>; in windows, this is an addition to <code>PATH</code>; in java, this is <code>java.library.path</code></li>
</ul><h3>Environment Modules</h3>

<p>Environment modules are exposed in two ways shell functions and source files.  These are used
to compose the runtime environment of the Instance.</p>

<ul><li>shell functions - defined in the init script itself to reduce footprint on the host.</li>
<li>source files  - files named <code>environment.bash</code> (on unix) or <code>environment.cmd</code> (on windows).</li>
</ul><h3>Environment scopes</h3>

<ul><li><p>CrossPlatform - shell function -  In order to work cross-platform and
without creating a lot of complexity, some shortcuts are taken.<br />
For example, the process depends on the <code>ps auxwww</code> command to work.<br />
As such, on Solaris hosts, this implies /usr/ucb/ps be found first in the <code>PATH</code>.<br />
Eventhough the path /usr/ucb isn't present on other UNIX-style hosts,
paths that are not found do not hurt anything.  Pragmatically, we prefix /usr/ucb to all
 unix paths so that we don't need to write a function to determine this per-platform.</p></li>
<li><p>Instance - shell function - sets up variables like <code>INSTANCE_NAME</code>, <code>LISTEN_HOST</code>, and <code>LISTEN_PORT</code></p></li>
<li><p>Platform - shell function - sets up additional variables like PATH and NATIVE_PATH, and
binds args to the above parameters.</p></li>
<li><p>Deployment - optional source file - any deviations needed for the specific application,
such as additional java args or classpath entries (in Java), or additional NATIVE_PATH for things like apache httpd.</p></li>
</ul><h2>Operations</h2>

<p>All operations need a minimum environment setup such that operations such as <code>ps</code> can operate.<br />
Accordingly, the init script InitBuilder creates always does the following:</p>

<ul><li>zero out environment variables known to conflict with applications</li>
<li>load CrossPlatform module</li>
</ul><h2>Sync</h2>

<p>Sync is a process that composes the environment of a process.  This is not performed inline,
as the running process may have a different version of variables from the prior one.<br />
Accordingly, Sync is used to establish a new environment for a process to run.<br />
In UNIX, this implies creation of a shell script, In Windows, this implies creation of a Service.</p>

<ul><li><p>Stop the service, if not already running</p>

<ul><li>this unlocks files that we may need to overwrite.  For example,
  in Windows the corresponding service must be stopped before it can be re-written.</li>
</ul></li>
<li><p>Load Instance module</p></li>
<li><p>Load Platform module</p></li>
<li><p>Load Deployment module</p></li>
<li><p>Write new Start process</p>

<ul><li><p>In Unix, this is technically a shell script that can be <code>nohup</code>ed.<br />
 This is named <code>${INSTANCE_NAME}.bash</code> in the <code>${CONFIG_DIR}</code></p></li>
<li><p>In Windows, we do two things: create a shell script and also a background process</p>

<ul><li>The shell script can be used to run the process in the foreground (as supported).<br />
  This is named <code>%INSTANCE_NAME%.cmd</code> in the <code>%CONFIG_DIR%</code></li>
<li>In Windows, it is typically difficult to get a simple shell script to operate
  in the background as a service non-attached to the current user.<br />
  As such, we use some tool to generate a service called <code>%INSTANCE_NAME%</code></li>
</ul></li>
</ul></li>
</ul><h2>Stop</h2>

<p>Stop the instance running in the background.  This is typically performed by
 looking for <code>INSTANCE_NAME</code> in the process table.  This implies that the <code>INSTANCE_NAME</code>
must be unique in the process table.</p>

<h2>Run</h2>

<p>Run the instance in the foreground (where possible).  This technically invokes the
  <code>${INSTANCE_NAME}.bash</code> or <code>%INSTANCE_NAME%.cmd</code> file previously created by Sync</p>

<h2>Start</h2>

<p>Start the process in the background.  In Unix, we nohup the  <code>${INSTANCE_NAME}.bash.  
In Windows, we execute</code>net start %INSTANCE_NAME%`;</p>

<h2>Status</h2>

<p>Returns <code>0</code> if the process is running, and <code>1</code> if the process isn't.</p>

<p><code>Last Updated: 2011-05-29</code></p>