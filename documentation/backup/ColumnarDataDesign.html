<h1>Columnar Data abstraction API</h1>

<h2>Introduction</h2>

<p>jclouds already support several abstractions, for instance computing services, blobstore, etc.
However jclouds was not supporting still an abstraction to Database-as-a-Service, mainly these that
are Data Columnar access. The goal of this create an abstraction to columnar data,
ex. simpledb, azure table, etc.</p>

<p>Nowadays there is a new trend to store information on these systems, into columnar data instead
 traditional relational system. This page explains the design for the abstraction.</p>

<p>The code was designed in a separated branch, until now.</p>

<p>http://github.com/bastiao/jclouds</p>

<p>Main author: Lu&#xED;s Basti&#xE3;o from IEETA/DETI @ Universidade de Aveiro,
and thanks for inputs from jclouds community.</p>

<h2>Scalability</h2>

<p>There are several problems regarding the scalability, that has to be solved in this
 abstraction. For instance, Amazon Simple DB use a horizontal scalability, i.e., different locations.
On the other side Azure Table use vertical one. For each partition key, represent
a different node to have the information.</p>

<p>In this case, it will be solved through the table id, that will identify the
Table name and the node label or location label.</p>

<h2>Details</h2>

<p>The abstraction will contain the LDC (Lowest Domain Common, and for now just
two API was being considered, but it might work with other tables.</p>

<h3>APIs</h3>

<p>In this section, we will discuss the different concepts in a Columnar Data.</p>

<p>We started by creating two files to create sync and asynchronous API</p>

<ul><li>AsyncDataColumnar</li>
<li>DataColumnar</li>
</ul><h4>Table</h4>

<p>Columnar Data abstraction taking two examples of cloud players: SimpleDB (AWS) and Azure Table.</p>

<p>They have a significative differences.
On one hand, SimpleDB they use a simple identifier (item name). On another hand,
Azure use a compose a element pair to create an identifier: {Partition Key, Row ID}</p>

<p>So first abstraction that I considered was an Identifier, then every instance has to implement one.</p>

<ul><li><strong>Create Table</strong></li>
</ul><p>The create table is strongly related with the scalability issue, so in that case the API will be something like:</p>

<pre><code>   public void createTable(String table);</code></pre>

<p>In a Columnar database, the data auto-fit into the table, and we don't need to design the
structure of table in the create action, because it has a mutable state.</p>

<ul><li><strong>Delete Table</strong></li>
</ul><p>The remove APi it is quite similar to the create, but more simple, just something like that:</p>

<pre><code>   public void removeTable(String table);</code></pre>

<ul><li><strong>Query</strong></li>
</ul><p>The query is an important mechanism to get data from a table in a database.
In this case the abstraction just support a simple select, and conditions to the product.
This implementation should be based on JPA implementation.</p>

<ul><li><strong>Select data</strong></li>
</ul><pre><code>// First arg is table name, and the second one is the list of fields to retrieve.
public Query createQuery(String table, List&lt;String&gt; fields);
public Query createNativeQuery(String sql);</code></pre>

<p>For instance</p>

<pre><code>SELECT A, B, C FROM Table </code></pre>

<ul><li><strong>Conditions</strong></li>
</ul><p>How to apply conditions/filter the query? First step, it will be create
a Query through the createQuery method. Thus, you should be able to filter the query.</p>

<pre><code>public void executeQuery();
public void setParameter(String name, String value);</code></pre>
Sample SQL:

<pre><code>SELECT A, B, C FROM Table WHERE name = :name </code></pre>
Then, you can apply the set

<pre><code>Query query = ColumnarObj.createNativeQuery("SELECT A, B, C FROM Table WHERE name = :name");
query.setParameter("name", "Luis");</code></pre>

<ul><li><strong>Insert</strong></li>
</ul><p>The insert mechanism, will be also using the abstraction of JPA, however
we will specialize into an Table implementation in order to receive attributes.</p>

<pre><code>public void persist(Table table);</code></pre>

<p>Moreover, it will have the same behavior, however merge operation will also be supported by this function.</p>

<ul><li><strong>Update</strong></li>
</ul><pre><code>new Exception("NOT SUPPORTED YET!!!");</code></pre>

<ul><li><strong>Remove</strong></li>
</ul><pre><code>public void remove(String table, String id);</code></pre>

<h2>Supported providers</h2>

<p>None until now on jclouds, but the simpledb implementation already lives in sandbox.</p>

<p><code>Last Updated: 2011-07-26</code></p>