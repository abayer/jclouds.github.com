<h1>Design of jclouds compute abstraction</h1>

<h2>Introduction</h2>

<p>jclouds goal is to provide simple tools developers can use to access resources in the cloud.<br />
We present both abstraction and value-add apis, making it the user's choice whether to lock-in to a
vendor's value-added feature, or avoid it with abstraction.</p>

<p>We also provide developers choice to either wait for the provider to finish a command (blocking), or
perform them in the background (async).  We do this in a way that works in many environments, including
google appengine and android.    To date, we provide over 10 cloud apis and an abstraction called BlobStore.
BlobStore offers Amazon S3-like portability across a few different cloud storage providers.</p>

<p>We've had high demand for a compute answer.  This document discusses our current thinking on that problem.</p>

<p>In the context of this design, compute basically means managing elastic operating systems.<br />
These could end up as Windows, or Linux, and their goal is to run platforms or applications.<br />
Most of the time, these end up implemented as virtual machines, but this design doesn't really care
 if they are bare metal or not.  What's cloud is that these operating systems are requested on-demand and
are only billed for the time they are running.</p>

<h2>Motivation</h2>

<p>There are a lot of service providers that provide this type of IaaS functionality,
ones currently supported by jclouds are <a href="http://aws.amazon.com/ec2/">Amazon EC2</a>,
<a href="http://www.rackspacecloud.com/cloud_hosting_products/servers">Rackspace Cloud Servers</a>,
<a href="http://www.vmware.com/appliances/services/vcloud-express.html">VMware vCloud API</a>, and
<a href="http://rimuhosting.com/vps/aboutvps.jsp">RimuHosting VPS</a>.</p>

<p>For better or worse, each of these services model their systems in different ways and
 therefore have different APIs to access them.  In some cases, there is large overlap in features.<br />
For example, there is generally an idea of an Image, which is basically a template operating system with
layered software which can be launched many times.  Some areas, there's less clear overlap.</p>

<p>For example, EC2 has a InstanceType, which declares the number or cores, amount of memory, etc.<br />
In other clouds, such as those running the VMware vCloud API, the user chooses the number of cores, memory, etc.<br />
Very often, services truly differentiate.  One example of this is Rackspace, who provides a scheduled backup service.</p>

<p>Even with differentiation, there are still enough overlaps to make useful abstractions across providers.<br />
Abstractions help avoid lock-in by presenting portable APIs that massage differences away.
There are a few good software projects that provide compute portability,
including <a href="http://incubator.apache.org/deltacloud/">deltacloud</a> (ruby and ReST),
<a href="http://github.com/geemus/fog">fog</a>(ruby), and <a href="http://www.dasein.org/">Dasein</a>(java).</p>

<p>This design does not replace or preclude any of the above.  Some of the apis above have scope much larger
than this design.  For example, Dasein covers features including networking technology.<br />
jclouds has a different development, integration, and usage focus.</p>

<p>For context, we'll these here:</p>

<ul><li><p>jclouds is first and foremost a JVM story.  We focus on being useful from Java, Groovy, Scala, JRuby, Clojure, and
any other JVM based language.  Java focus allows us to present advanced features such as Futures and
pluggable configuration without the user having to deal with how these actually work.</p></li>
<li><p>jclouds is an integration platform.  We encourage other tools, like Dasein and ShrinkWrap,
to integrate with us.  We don't want to divert focus and attempt to solve
every cloud problem down to the gui.  Ecosystems matter.  We want our design end up simple,
but feature-rich enough to build platforms on.</p></li>
<li><p>jclouds wants to allow service providers to present value-added features.<br />
Abstractions are nice, but often too limited to solve the specific task of the user.<br />
We do not want to discourage innovation by precluding access to vendor apis.<br />
Every abstraction we present also presents the native vendor functionality.<br />
This allows the developer choice to make the right call.<br />
If you can do 90% with abstraction, great!  That said, we don't want you to have to learn and
 manage a different framework to get to that last 10%.</p></li>
</ul><p>As said above, shared vocabulary is important. Where it makes sense, we'll try
to use vocabulary present in other cloud apis such as Apache Deltacloud, Fog, Dasein, and vCloud.<br />
Using the same vocabulary will widen the understanding of jclouds compute abstraction and
 easily show similarities/differences.</p>

<p>Considering the above, we have the following goals:</p>

<ul><li><p> make it easy to manage the lifecycle of compute nodes in the cloud by
reducing the provider specific details required to operate.</p></li>
<li><p> provide clear integration paths for open source tools such as ant, maven, hudson, cargo, and controltier</p></li>
<li><p> model location as a first class concept, where location is a virtual datacenter, or cloud provider endpoint.</p></li>
</ul><p>We have extended goals of:</p>

<ul><li> make it easy to map jclouds concepts to concepts present in other cloud apis</li>
<li> model operating systems in a more resource oriented way</li>
</ul><p>The compute design is based on the above context and the knowledge of the many involved.<br />
At the time of this writing, we are in first draft state.  Please get involved and participate.<br />
This is a community design.</p>

<h2>Design</h2>

<h3>Vocabulary</h3>

<p>For this design, we have the current working vocabulary.</p>

<ul><li><p><em>ComputeService</em> - a service level api endpoint such as EC2.<br />
Contains an inventory of of Hardware profiles, Images, and Nodes.<br />
Also contains the ability to create and destroy Nodes and resolve Templates.</p></li>
<li><p><em>Provider</em> - Runs a compute provisioning api such as vCloud, EC2, etc.<br />
May run multiple endpoints (ex. west, east, north).  Context is generally bound to a provider and
a unique identity within it.</p></li>
<li><p><em>Image</em> - A pre-configured operating system representing the base software a new Node will run.<br />
This is a part of the template used to create nodes.</p></li>
<li><p><em>Hardware</em> - a set of resource configuration that includes at least memory, cpu, and disk.<br />
This size may act on an "at least" principle which guarantees at least the resources listed profile,
but possibly more. This is a required input to Server creation.</p></li>
<li><p><em>Location</em> - an assignable physical or logical location inside a provider where you can launch nodes.<br />
Location can be scoped as Provider, Region, Zone, etc, so that you can determine its precision.<br />
This is often a virtual or physical datacenter. This is a required input to Server creation.</p></li>
<li><p><em>TemplateOptions</em> - options for creations of resources, including ports to open, scripts
to run at bootstrap.  Can be extended per provider to expose vendor hooks.</p></li>
<li><p><em>Template</em> - Composite if Image, Hardware, Location and TemplateOptions for Node creation.<br />
This allows for repeated creation of Nodes.</p></li>
<li><p><em>Node</em> - An named instance of a Template.  Sometimes called a server, vApp, or virtual machine.<br />
This typically has login, ip, and security metadata.</p></li>
<li><p><em>Group</em> - A name that aggregates nodes and related incidental resources such as keys,
so that you can control groups of nodes as a unit.  As many clouds do not support multiple groups,
our use of group implies a primary grouping.</p></li>
</ul><h3>Platform Extension</h3>

<p>Via extension, the NodeService has means to create Instances of Platforms on Nodes, and may do so by default.</p>

<ul><li><p><em>Platform</em> - an archive of bundled code and configuration that presents a value-added service to applications.<br />
Examples include application servers like Tomcat, a database like MySql, network memory like Terracotta.</p></li>
<li><p><em>Instance</em> - a running instance of a Platform, typically associated with a process on the host operating system.<br />
Metadata typically includes at least environment variables and often ip socket data.</p></li>
</ul><h2>Node Service</h2>

<h3>Resource-Oriented as opposed to OO</h3>

<p>Providing a resource-oriented interface as opposed to
an object oriented one allows outside integrators the following flexibility:</p>

<ul><li><p>Create their own OO interfaces that may not match ours</p></li>
<li><p>Simple access to both synchronous and asynchronous apis, without the need for mirrored object trees.</p></li>
<li><p>Ability to easily stand up a Rest service that simply delegates to jclouds calls.</p></li>
</ul><h2>Node</h2>

<h3>State Machine</h3>

<p>Node is a view of a host's running operating system with state.<br />
Whether or not you are personally connected to it, the node exists in some state from
the time it is created until someone invokes the destroy method.<br />
When a node is created, it is implicitly started.  This is due to the reality
that most providers start their nodes when they are created, and there is no way to disable this.</p>

<p>Like other jclouds components, this will have asynchronous calls (<em>note async is not implemented, yet</em>).<br />
However, we will have helpers for calls that always take a long time.</p>

<p>Here's what creating and starting an Node might look like if you let jclouds handle reasonable timeouts:</p>

<pre><code>// setup an option to wait up to 120 seconds for port 22 to open
TemplateOptions options = computeService.templateOptions().blockOnPort(22, 120);
// run a single node accessible via the group "foo"
Set&lt;? extends NodeMetadata&gt; nodes = computeService.runNodesInGroup("foo", 1, options);</code></pre>

<h2>Template</h2>

<p>A template provides an ability to encapsulate the implementation details corresponding to a user's desires.<br />
For example, a user may desire the cheapest node configuration in dallas.  <code>computeService.templateBuilder()</code> would accept
 arguments to return the best match of this request.  The Template is then used to create a node, for example:</p>

<pre><code>Template template = computeService.templateBuilder().hardwareId(InstanceType.M1_SMALL)
              .osVersionMatches("10.04").imageDescriptionMatches("ubuntu-images").osFamily(OsFamily.UBUNTU).build();

// run 5 nodes accessible with the group "webserver"
Set&lt;? extends NodeMetadata&gt; nodes = computeService.runNodesInGroup("webserver", 5, template);
</code></pre>

<p>As you can see above, Profile allows users to use cloud-specific lookups while at the same time use the portable interface.<br />
It also allows you to create multiple nodes.</p>

<h2>Use Cases</h2>

<p><em>please extend!</em></p>

<h3>Provisioning</h3>

<ul><li>specifying Profiles</li>
<li>creating and starting Servers with specified Profiles and Images</li>
<li>specifying Platforms</li>
<li>creating Instances of Platforms on existing Servers</li>
<li>suspending and stopping Instances and Servers</li>
<li>scheduling the creation, starting, suspending or stopping of Instances or Servers</li>
</ul><h3>Monitoring</h3>

<ul><li>retrieve information on running Nodes (i.e. mainly "low-level" info)</li>
<li>retrieve information on running Instances (i.e. data specific to the software in the Platform running on the Instance)</li>
<li>query information across a set of Instances or Nodes (e.g. "show me all nodes with a CPU load &gt; X")</li>
<li>request to be notified if a certain Node or Instance metric reaches a defined threshold value</li>
</ul><p>The above are fairly "fine-grained" use cases, and as such it would appear helpful to add some higher-level context in terms of applications or scenarios in which these Use Cases might occur.</p>

<ul><li>Provisioning as part of the build cycle, e.g. from [http://ant.apache.org/ Ant], [http://cargo.codehaus.org/ Cargo] or [https://hudson.dev.java.net/ Hudson]</li>
<li>Monitoring from existing infrastructure monitors, e.g. [http://www.nagios.org/about/ Nagios]</li>
<li>Monitoring from within a cloud application</li>
<li>Monitoring and auto-provisioning from an infrastructure management application, e.g. a [http://en.wikipedia.org/wiki/Hypervisor hypervisor] or [http://www.rightscale.com/ RightScale]</li>
<li>Monitoring and auto-provisioning from an application platfrom, e.g. [http://www.gigaspaces.com/ GigaSpaces]</li>
</ul><h2>Platform Extension</h2>

<p><code>Note this isn't implemented as of jclouds 1.0.0</code></p>

<h2>Container</h2>

<p>The node has operations, but also acts as a container for Platforms and Instances of them. <br />
Here's what that might look like in java:</p>

<pre><code>if (!node.containsPlatform("mybilling-1.0.1")){
   Archive billingArchive = // from archive
   Future&lt;PlatformMetadata&gt; = service.createPlatform(node.getId(), "mybilling-1.0.1", archive, readOnly().onSharedMount(volume));
   // validate  
}

SortedSet&lt;InstanceMetadata&gt; billingInstances = service.listInstances(node.getId(), platform("mybilling-1.0.1").groups("production"));

if (billingInstances.size() &lt;5){
  Future&lt;Instance&gt;  = service.createInstance(node.getId(), "mybilling-1.0.1", groupAs("production"));
  //  check it, etc.
}
</code></pre>

<p><code>Last Updated: 2011-07-26</code></p>